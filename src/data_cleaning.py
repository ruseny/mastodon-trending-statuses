"""
This module defines a number of functions that can be
used for common preprocessing and data cleaning tasks
on a dataframe of mastodon statuses.
"""

# Dependencies
import pandas as pd
from datetime import datetime
from bs4 import BeautifulSoup
import re

# Extracting text, removing html tags
def get_stripped_text(df):
    """
    Removes all html tags from status texts as found 
    in column 'content', stores the stripped text in 
    a new column 'stripped_content', and returns the
    dataframe.
    """

    def soup_extract(content):
        text = str(content)
        soup = BeautifulSoup(text, "html.parser")
        return soup.get_text()
    
    df["content_stripped"] = df["content"].map(soup_extract)
    
    return df

# Extracting text, removing html tags, replacing hashtag and mention symbols
def get_annotated_text(df):
    """
    Removes all html tags, as well as # and @ symbols
    from status texts as found in column 'content.
    Inserts annotations before hashtags with '_hashtag_ ', 
    mentions with '_mention_ ', and external links 
    with '_link_ '. Stores the annotated text in a new
    column 'content_annotated', and returns the dataframe.
    """

    def soup_process(content):
        text = str(content)
        soup = BeautifulSoup(text, "html.parser")

        for hm_tag in soup.find_all("a", ["hashtag", "mention"]):
            hashtag_mention = hm_tag.get_text()
            if hashtag_mention[0] == "#":
                hashtag_mention = "_hashtag_ " + hashtag_mention[1:]
            elif hashtag_mention[0] == "@":
                hashtag_mention = "_mention_ " + hashtag_mention[1:]
            hm_tag.replace_with(hashtag_mention)
        
        for a_tag in soup.find_all("a"):
            external_link = a_tag.get_text()
            external_link = "_link_ " + external_link
            a_tag.replace_with(external_link)
        
        return soup.get_text()
    
    df["content_annotated"] = df["content"].map(soup_process)
    
    return df

# Extracting text, removing html tags, removing links
def get_text_no_links(df):
    """
    Removes all html tags, as well as the links, including
    # and @ tags and external links, stores the resulting text
    in a new column 'content_plain_text', and returns the df.
    """

    def soup_process(content):
        text = str(content)
        soup = BeautifulSoup(text, "html.parser")

        for a_tag in soup.find_all("a"):
            a_tag.replace_with("")
        
        return soup.get_text()
    
    df["content_plain_text"] = df["content"].map(soup_process)
    
    return df

# Measuring content length
def get_content_length(df):
    """
    Counts the number of words, or set of alphanumeric characters, 
    as separated by single or multiple whitespace characters.
    Uses the text from 'content_plain_text' column; if this
    does not exist, calls get_text_no_links() function to create
    the column. Creates a new column 'content_length' for the
    count and returns the dataframe.
    """

    if df["content_plain_text"] is None:
        df = get_text_no_links(df)
    
    df["content_length"] = df["content_plain_text"].map(
        lambda text: len(text.split())
    )

    return df


# datetime datatype
def convert_to_datetime(df, cols_to_convert: list = [
    "created_at", 
    "edited_at", 
    "account_created_at", 
    "account_last_status_at", 
    "card_published_at", 
    "poll_expires_at"
    ], add_col: list = None, remove_col: list = None, 
    dt_format: dict = None):

    """
    Converts the main columns that have datetime information
    into datetime data type.
    Arguments:
    - df: pandas dataframe of mastodon statuses, ideally generated by 
    TrendingStatuses class method generate_df
    - cols_to_convert (list of strings): list of column names to be converted to
    datetime data type. The default list includes the standard
    columns that have datetime information. 
    - add_col (list of strings): additional columns that need to be
    converted to datetime data type.
    - remove_col (list of strings): columns to be removed from the list
    of columns that will be converted
    - dt_format (dict): dictionary to map datetime formats to column
    names. Especially useful if additional columns have been specified.
    Can also update the format for default columns if the function's 
    defaults don't work.
    Returns: processed dataframe
    """

    columns = []
    for col in cols_to_convert:
        if col in df.columns:
            columns.append(col)

    if add_col is not None:
        for col in add_col:
            if col in df.columns:
                columns.append(col)

    if remove_col is not None:
        for col in remove_col:
            if col in columns:
                columns.remove(col)
    
    formats = {
        "created_at" : "%Y-%m-%dT%H:%M:%S.%fZ", 
        "edited_at" : "%Y-%m-%dT%H:%M:%S.%fZ", 
        "account_created_at" : "%Y-%m-%dT%H:%M:%S.%fZ", 
        "account_last_status_at" : "%Y-%m-%d", 
        "card_published_at" : "%Y-%m-%dT%H:%M:%S.%fZ", 
        "poll_expires_at" : "%Y-%m-%dT%H:%M:%S.%fZ"
    }

    if dt_format is not None:
        formats.update(dt_format)
    
    for col in columns:
        def dt_converter(dt_str):
            try:
                return datetime.strptime(dt_str, formats[col])
            except:
                return pd.NaT
        df[col] = df[col].map(dt_converter)
    
    return df

# account age
def calculate_account_age(df):
    """
    This function creates a new column for account age in days.
    It takes into account the date-time of the most recent status.
    The columns created_at and account_created_at must be of 
    datetime data type.
    Returns the df with the new column.
    """
    last_status_day = max(df["created_at"])
    def subs_days(dt):
        try:
            return (last_status_day - dt).days
        except:
            return pd.NaT
    df["account_age"] = df["account_created_at"].map(subs_days)
    return df

# a function to count list items, even when the data comes
# as a string representation of json, which will be used
# for tags, media, mentions, and emojis
def count_items(content):
    if type(content) == list:
        return len(content)
    elif type(content) == str:
        try:
            eval_list = eval(content)
            if type(eval_list) == list:
                return len(eval_list)
            else:
                return pd.NA
        except:
            return pd.NA
    else:
        return pd.NA

# a function to return 1 for count > 0, 0 otherwise
def is_present(item_count):
    if pd.isna(item_count):
        return pd.NA
    else:
        return int(item_count > 0)

# tag info    
def get_tag_info(df):
    """
    This function takes the tags column of a dataframe of
    mastodon statuses, and creates a new column of strings
    consisting of tags separated by whitespace. This new
    column can be convient to check if a certain is included.
    The new column name is tags_str.
    This also adds a column for the number of tags (tag_count), 
    and if any tag is present (any_tag).
    Returns the df with the new column.
    """
    # a helper function to do conversions
    # the tags column has the form of list of dicts where name is the key for each tag
    def dict_names_to_string(content):
        if type(content) == list:
            list_of_dicts = content
        elif type(content) == str:
            try:
                list_of_dicts = eval(content)
            except:
                list_of_dicts = []
        else:
            list_of_dicts = []

        try:
            tag_name = " "
            for dt in list_of_dicts:
                tag_name += dt["name"] + " "
            return tag_name.strip()
        except:
            return ""
    
    df["tags_str"] = df["tags"].map(dict_names_to_string)
    df["tag_count"] = df["tags"].map(count_items)
    df["any_tag"] = df["tag_count"].map(is_present)

    return df

# media info
def get_media_info(df):
    """
    Creates two new columns in a dataframe of mastodon statuses,
    one with the number of media attachments (media_count), and one 
    showing if there are any media attachments (any_media).  
    """
    
    df["media_count"] = df["media_attachments"].map(count_items)
    df["any_media"] = df["media_count"].map(is_present)
    return df
    
# mention info
def get_mention_info(df):
    """
    Creates two new columns in a dataframe of mastodon statuses,
    one with the number of mentions (mention_count), and one showing 
    if there are any mentions (any_mention).  
    """

    df["mention_count"] = df["mentions"].map(count_items)
    df["any_mention"] = df["mention_count"].map(is_present)
    return df
    
# emoji info
def get_emoji_info(df):
    """
    Creates two new columns in a dataframe of mastodon statuses,
    one with the number of emojis (emoji_count), and one showing 
    if there are any emojis (any_emoji).  
    """
    df["emoji_count"] = df["emojis"].map(count_items)
    df["any_emoji"] = df["emoji_count"].map(is_present)
    return df

# card info
def get_card_info(df):
    """
    Creates two new columns in a dataframe of mastodon statuses,
    processing the information on cards. The first new column contains
    more useful card categories, converting null values to "no card". 
    The second new column shows if there is any card.
    """
    # helper function to map values to new categories
    def card_categorise(card_type): 
        cat = "No card"
        if card_type == "link":
            cat = "link"
        elif card_type == "video":
            cat = "video/photo"
        elif card_type == "photo":
            cat = "video/photo"
        return cat
    df["card_categories"] = df["card_type"].map(card_categorise)
    df["any_card"] = df["card_categories"].map(lambda cat: 0 if cat == "No card" else 1)
    return df


def clean_data(df, strip_text = True, annotate_text = True, no_link_text = True, 
               content_length = True, datetime = True, account_age = True, 
               tags = True, media = True, mention = True, emoji = True, card = True):
    """
    This is a convenience function to apply all or some of the functions 
    of this module in one go. By default, all functions are applied.
    """

    if strip_text:
        df = get_stripped_text(df)
    if annotate_text:
        df = get_annotated_text(df)
    if no_link_text:
        df = get_text_no_links(df)
    if content_length:
        df = get_content_length(df)
    if datetime:
        df = convert_to_datetime(df)
    if account_age:
        df = calculate_account_age(df)
    if tags:
        df = get_tag_info(df)
    if media:
        df = get_media_info(df)
    if mention:
        df = get_mention_info(df)
    if emoji:
        df = get_emoji_info(df)
    if card:
        df = get_card_info(df)
    return df

# keep only posts marked as english and written with mostly alphanum characters
def keep_only_english(df):
    df = df[df["language"] == "en"].copy()

    if df["content_plain_text"] is None:
        df = get_text_no_links(df)
    
    if df["content_length"] is None:
        df = get_content_length(df)
    
    def keep_alphanum(text):
        text = re.sub(r'[^A-Za-z0-9\s]+', '', text)
        text = re.sub(r'\s+', ' ', text)
        return text.strip()
    
    df["content_only_alphanum"] = df["content_plain_text"].map(keep_alphanum)
    df["content_length_alphanum"] = df["content_only_alphanum"].map(
        lambda text: len(text.split())
    )

    df["alphanum_ratio"] = df["content_length_alphanum"] / df["content_length"]
    df = df[df["alphanum_ratio"] > 0.5].copy()

    return df

# Reducing the dataset to columns needed for further analyses and modelling
def reduce_df(df, 
                cols_to_keep: list = ['id', 'created_at', 'language', 'replies_count', 
                                      'reblogs_count', 'favourites_count', 'content_stripped', 
                                      'content_annotated', 'content_plain_text', 'content_length', 
                                      'content_only_alphanum', 'content_length_alphanum',
                                      'account_id', 'account_bot', 'account_created_at', 
                                      'account_followers_count', 'account_following_count', 
                                      'account_statuses_count', 'account_last_status_at', 
                                      'account_age','tags_str', 'tag_count', 'any_tag',  
                                      'media_count', 'any_media', 'mention_count', 'any_mention', 
                                      'emoji_count', 'any_emoji', 'card_categories', 'any_card'], 
                 add_col: list = None, remove_col: list = None):
    """
    This function takes a dataframe of mastodon statuses, 
    and returns a smaller dataframe with columns likely to be used 
    in EDA, if they already exist in the provided dataframe.
    Arguments:
    - df: dataframe to be reduced
    - cols_to_keep: a list of column names to keep with a default.
    - add_col (list): list of column names to add to the list to keep.
    - remove_col (list): list of column name to remove from the existing list to keep.
    """
    columns = []
    for col in cols_to_keep:
        if col in df.columns:
            columns.append(col)
    if add_col is not None:
        for col in add_col:
            if col in df.columns:
                columns.append(col)
    if remove_col is not None:
        for col in remove_col:
            if col in columns:
                columns.remove(col)
    columns = sorted(set(columns), key=columns.index)
    return df[columns].copy()